

#version 460

#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_debug_printf : enable

layout(push_constant) uniform PushConstants {
    uint flag;
    uint frame;
} pushConstants;

layout (rgba16f, set = 0, binding = 0) uniform image2D imageOutput;

layout (r32ui, set = 0, binding = 2) uniform uimage2D positionImage;

layout (set = 0, binding = 3, r8ui) uniform readonly uimage3D voxelData[512];
layout (set = 0, binding = 4, r16ui) uniform readonly uimage3D voxelChunkMap;

layout (set = 0, binding = 5, r32ui) uniform uimage2D lightImageX;
layout (set = 0, binding = 6, r32ui) uniform uimage2D lightImageY;
layout (set = 0, binding = 7, r32ui) uniform uimage2D lightImageZ;
layout (set = 0, binding = 8, r32ui) uniform uimage2D lightImageW;

float random[2048] = 
{
    0.34726, 0.14563, 0.29785, 0.97120, 0.50034, 0.21764, 0.63222, 0.53065, 0.76978, 0.65596, 0.45390, 0.57666, 0.72960, 0.78645, 0.48682, 0.93867, 0.32638, 0.33044, 0.70833, 0.06614, 0.33730, 0.45958, 0.99819, 0.85164, 0.66563, 0.93702, 0.54812, 0.05921, 0.32477, 0.26433, 0.68041, 0.83918, 0.64120, 0.43182, 0.46826, 0.74880, 0.94558, 0.11371, 0.00674, 0.54190, 0.94562, 0.99676, 0.84224, 0.69063, 0.25264, 0.41537, 0.40938, 0.62149, 0.56714, 0.61636, 0.64913, 0.83959, 0.78043, 0.78587, 0.72718, 0.35976, 0.50642, 0.77051, 0.71881, 0.36223, 0.14066, 0.57467, 0.50077, 0.28693, 0.05050, 0.34871, 0.89755, 0.07397, 0.07349, 0.27610, 0.49344, 0.83332, 0.38790, 0.96328, 0.65524, 0.26634, 0.85799, 0.70377, 0.40458, 0.10406, 0.33942, 0.62362, 0.74058, 0.86113, 0.53983, 0.05273, 0.82271, 0.77054, 0.72988, 0.55630, 0.94350, 0.89082, 0.27243, 0.64851, 0.38687, 0.64888, 0.08677, 0.32814, 0.39729, 0.48411, 0.20817, 0.04053, 0.00993, 0.55195, 0.18355, 0.48463, 0.60802, 0.20916, 0.63935, 0.82691, 0.32867, 0.37053, 0.88903, 0.12057, 0.85647, 0.68921, 0.60703, 0.16423, 0.27522, 0.09008, 0.92883, 0.80070, 0.48137, 0.60311, 0.30592, 0.78926, 0.77929, 0.45694, 0.13516, 0.57951, 0.80137, 0.06055, 0.94822, 0.84531, 0.40301, 0.39085, 0.80179, 0.85584, 0.76983, 0.90072, 0.02379, 0.78497, 0.63500, 0.27936, 0.75166, 0.30601, 0.24926, 0.06777, 0.60718, 0.30773, 0.04888, 0.52334, 0.63071, 0.55706, 0.35500, 0.46590, 0.89062, 0.70457, 0.30294, 0.82773, 0.99550, 0.89695, 0.26650, 0.74163, 0.44612, 0.29186, 0.38466, 0.09936, 0.43791, 0.38134, 0.97822, 0.96092, 0.14851, 0.90583, 0.24731, 0.44733, 0.50612, 0.10928, 0.30914, 0.71301, 0.10668, 0.98570, 0.82502, 0.20868, 0.07115, 0.69187, 0.57651, 0.39833, 0.87097, 0.15012, 0.55428, 0.22735, 0.78752, 0.26393, 0.95807, 0.17464, 0.45802, 0.09242, 0.54988, 0.39957, 0.64604, 0.36689, 0.66202, 0.73237, 0.04228, 0.59658, 0.50138, 0.93180, 0.63021, 0.44442, 0.37961, 0.28387, 0.80919, 0.11901, 0.13422, 0.86635, 0.92707, 0.69070, 0.59032, 0.28305, 0.05697, 0.10283, 0.73198, 0.38101, 0.38032, 0.35947, 0.18744, 0.50591, 0.67219, 0.22013, 0.41806, 0.49120, 0.15048, 0.09775, 0.38444, 0.25435, 0.75012, 0.16170, 0.07514, 0.70953, 0.58719, 0.38322, 0.59145, 0.07973, 0.61337, 0.19764, 0.63913, 0.89249, 0.27924, 0.82377, 0.50469, 0.15902, 0.32801, 0.01235, 0.39313, 0.87617, 0.32736, 0.38419, 0.47140, 0.05187, 0.77582, 0.50902, 0.24349, 0.74781, 0.77268, 0.33862, 0.86393, 0.97341, 0.86823, 0.57947, 0.75731, 0.24717, 0.66701, 0.28984, 0.40310, 0.44415, 0.04508, 0.10123, 0.65071, 0.18285, 0.31155, 0.77321, 0.52777, 0.51094, 0.62583, 0.61600, 0.42656, 0.36251, 0.29050, 0.07532, 0.96889, 0.58008, 0.20330, 0.95367, 0.60652, 0.77833, 0.45218, 0.29537, 0.38982, 0.73487, 0.52064, 0.65271, 0.51348, 0.90996, 0.35939, 0.69018, 0.13147, 0.30953, 0.01734, 0.64482, 0.38214, 0.63209, 0.45029, 0.72837, 0.66004, 0.08176, 0.14400, 0.27011, 0.43095, 0.11109, 0.69435, 0.11369, 0.68688, 0.26475, 0.05211, 0.42986, 0.64694, 0.74029, 0.28865, 0.42284, 0.32187, 0.27277, 0.55275, 0.44806, 0.15932, 0.70259, 0.14267, 0.08426, 0.58701, 0.23737, 0.83976, 0.96664, 0.66495, 0.15820, 0.41306, 0.39328, 0.84208, 0.00342, 0.89958, 0.92785, 0.53106, 0.30669, 0.17414, 0.89635, 0.81176, 0.82493, 0.56408, 0.30362, 0.01118, 0.32240, 0.90750, 0.04225, 0.95126, 0.43294, 0.34027, 0.56091, 0.72722, 0.37798, 0.77670, 0.91632, 0.87047, 0.45907, 0.37936, 0.22679, 0.44447, 0.11969, 0.42288, 0.42393, 0.28544, 0.80779, 0.39705, 0.99103, 0.94946, 0.52343, 0.37468, 0.11808, 0.04200, 0.70297, 0.56071, 0.55042, 0.57394, 0.62842, 0.87264, 0.62384, 0.43715, 0.81456, 0.72863, 0.18788, 0.05363, 0.26341, 0.21277, 0.74825, 0.90086, 0.31781, 0.96136, 0.94796, 0.68082, 0.35193, 0.43613, 0.52212, 0.40640, 0.47911, 0.39298, 0.70265, 0.90632, 0.02826, 0.66269, 0.95221, 0.59593, 0.02536, 0.08548, 0.18020, 0.05110, 0.71551, 0.70016, 0.13731, 0.75132, 0.39329, 0.09806, 0.39691, 0.78506, 0.21536, 0.73270, 0.74215, 0.86800, 0.33750, 0.49668, 0.91381, 0.92137, 0.91357, 0.95510, 0.55633, 0.90711, 0.09756, 0.71119, 0.97014, 0.25756, 0.18971, 0.84952, 0.09492, 0.52478, 0.17305, 0.68940, 0.92967, 0.59348, 0.23749, 0.11972, 0.89903, 0.64174, 0.43100, 0.85397, 0.21810, 0.02415, 0.69970, 0.35323, 0.62935, 0.51926, 0.70252, 0.47080, 0.70037, 0.15633, 0.72441, 0.46061, 0.94245, 0.52015, 0.60305, 0.38372, 0.64298, 0.10852, 0.82276, 0.22997, 0.76235, 0.54159, 0.31792, 0.96483, 0.48816, 0.11267, 0.50888, 0.27057, 0.12171, 0.65316, 0.60137, 0.77041, 0.59294, 0.85632, 0.95800, 0.15394, 0.38928, 0.67651, 0.71120, 0.03650, 0.32121, 0.91597, 0.97143, 0.95616, 0.07363, 0.12474, 0.49576, 0.02838, 0.90383, 0.05742, 0.89814, 0.59886, 0.41578, 0.91101, 0.52286, 0.39510, 0.12401, 0.45242, 0.97810, 0.86493, 0.99763, 0.96462, 0.18921, 0.14799, 0.20844, 0.24508, 0.11193, 0.32556, 0.33354, 0.46225, 0.26909, 0.61067, 0.46242, 0.76248, 0.74416, 0.98314, 0.87319, 0.35471, 0.15346, 0.71100, 0.06700, 0.61407, 0.88682, 0.82585, 0.96334, 0.19605, 0.35807, 0.06279, 0.15179, 0.96180, 0.43252, 0.14033, 0.76168, 0.08802, 0.42904, 0.41154, 0.57067, 0.73633, 0.20406, 0.84689, 0.04299, 0.02502, 0.49341, 0.05475, 0.88750, 0.87499, 0.60143, 0.90989, 0.38689, 0.66953, 0.01358, 0.80561, 0.06140, 0.28116, 0.10678, 0.50741, 0.59538, 0.26079, 0.56924, 0.38257, 0.45895, 0.53211, 0.38274, 0.05999, 0.41326, 0.74975, 0.61318, 0.28606, 0.31308, 0.49219, 0.22004, 0.80257, 0.72072, 0.17778, 0.48766, 0.92118, 0.69541, 0.26009, 0.18521, 0.70622, 0.24148, 0.84164, 0.47055, 0.73174, 0.43526, 0.30365, 0.50981, 0.20746, 0.39419, 0.35085, 0.93232, 0.04903, 0.52460, 0.17694, 0.91183, 0.86755, 0.44616, 0.81542, 0.06178, 0.43753, 0.94306, 0.43192, 0.36071, 0.44080, 0.96482, 0.95875, 0.66431, 0.69902, 0.08251, 0.00092, 0.54510, 0.89156, 0.49815, 0.35264, 0.30030, 0.58353, 0.02216, 0.57534, 0.42058, 0.05684, 0.56177, 0.76327, 0.66559, 0.92001, 0.82488, 0.33969, 0.69623, 0.64492, 0.87176, 0.59858, 0.83140, 0.67851, 0.93413, 0.56196, 0.22144, 0.69053, 0.13815, 0.92212, 0.55955, 0.49301, 0.03085, 0.00258, 0.34382, 0.99824, 0.75763, 0.25745, 0.72482, 0.44680, 0.68605, 0.57847, 0.74351, 0.57424, 0.94843, 0.24415, 0.31722, 0.01885, 0.62696, 0.92517, 0.56858, 0.61124, 0.48750, 0.09757, 0.68816, 0.64639, 0.12810, 0.25819, 0.39246, 0.75208, 0.80747, 0.79918, 0.86805, 0.33006, 0.86892, 0.47198, 0.68020, 0.27574, 0.76844, 0.71914, 0.81781, 0.87437, 0.69095, 0.48594, 0.55333, 0.99108, 0.26458, 0.36917, 0.09890, 0.41663, 0.81783, 0.09663, 0.64600, 0.49642, 0.42433, 0.60410, 0.26965, 0.54972, 0.57717, 0.47967, 0.62713, 0.34132, 0.43093, 0.75715, 0.21227, 0.99822, 0.43001, 0.29341, 0.68177, 0.48722, 0.34595, 0.50229, 0.75444, 0.29382, 0.57308, 0.74694, 0.70376, 0.25666, 0.58802, 0.08610, 0.68099, 0.15314, 0.01892, 0.51237, 0.15624, 0.77039, 0.60837, 0.73341, 0.44037, 0.59831, 0.94546, 0.04483, 0.56200, 0.35350, 0.85792, 0.85228, 0.46841, 0.01593, 0.81034, 0.24314, 0.51541, 0.63037, 0.22256, 0.54019, 0.35785, 0.31238, 0.66461, 0.53976, 0.31470, 0.89424, 0.60841, 0.84983, 0.82209, 0.36689, 0.58666, 0.37566, 0.08624, 0.92591, 0.73245, 0.27849, 0.46367, 0.73925, 0.44068, 0.57728, 0.44035, 0.38530, 0.38600, 0.72724, 0.93058, 0.15262, 0.29421, 0.77701, 0.48775, 0.08810, 0.97940, 0.24897, 0.33600, 0.89250, 0.50999, 0.18392, 0.05852, 0.68138, 0.71563, 0.58899, 0.58210, 0.33134, 0.92664, 0.57638, 0.08711, 0.26044, 0.08594, 0.38007, 0.21757, 0.85698, 0.09821, 0.25094, 0.47583, 0.29774, 0.12348, 0.14414, 0.28249, 0.34269, 0.45023, 0.27648, 0.91816, 0.49629, 0.62201, 0.88327, 0.39838, 0.50929, 0.08257, 0.99190, 0.79570, 0.52709, 0.58749, 0.61571, 0.25324, 0.64963, 0.30181, 0.14403, 0.47994, 0.46228, 0.73668, 0.94198, 0.62826, 0.95016, 0.71824, 0.75546, 0.89119, 0.19976, 0.33131, 0.50832, 0.36878, 0.34835, 0.89301, 0.58964, 0.55823, 0.05052, 0.02490, 0.29063, 0.05021, 0.65523, 0.10181, 0.23626, 0.89653, 0.71284, 0.36989, 0.07793, 0.37253, 0.28821, 0.51300, 0.34069, 0.10028, 0.50146, 0.68282, 0.37997, 0.09708, 0.31754, 0.89506, 0.66662, 0.81537, 0.00672, 0.27674, 0.28548, 0.02744, 0.66430, 0.40667, 0.35003, 0.95639, 0.70220, 0.08249, 0.12165, 0.38206, 0.12966, 0.02298, 0.31801, 0.19166, 0.04334, 0.32590, 0.31056, 0.19337, 0.39341, 0.93395, 0.63316, 0.95865, 0.65909, 0.20177, 0.91760, 0.98255, 0.10666, 0.83611, 0.35972, 0.24731, 0.89846, 0.70827, 0.69478, 0.72896, 0.35515, 0.70238, 0.61135, 0.67527, 0.15615, 0.68677, 0.48851, 0.10692, 0.00625, 0.09231, 0.15868, 0.58669, 0.94830, 0.86871, 0.42189, 0.85740, 0.25324, 0.20450, 0.70236, 0.60245, 0.99135, 0.17518, 0.54189, 0.72458, 0.32251, 0.62322, 0.33642, 0.36299, 0.72857, 0.35066, 0.95994, 0.57235, 0.77256, 0.02655, 0.91639, 0.41622, 0.83415, 0.94044, 0.85546, 0.18846, 0.65206, 0.51171, 0.16464, 0.78855, 0.15531, 0.12671, 0.51933, 0.30650, 0.88024, 0.73605, 0.37492, 0.04223, 0.91388, 0.57573, 0.32322, 0.53083, 0.58101, 0.37191, 0.69167, 0.87661, 0.48119, 0.95158, 0.25793, 0.02838, 0.01044, 0.58656, 0.18853, 0.91461, 0.33146, 0.86789, 0.35019, 0.76391, 0.09554, 0.26889, 0.40170, 0.02969, 0.74979, 0.44109, 0.40130, 0.33548, 0.91129, 0.48773, 0.90205, 0.76814, 0.05603, 0.36008, 0.32603, 0.40077, 0.77117, 0.12321, 0.44403, 0.45840, 0.72891, 0.97641, 0.97620, 0.06170, 0.10105, 0.77411, 0.20691, 0.54943, 0.92525, 0.90604, 0.48350, 0.95709, 0.88694, 0.51269, 0.61384, 0.70154, 0.99064, 0.98092, 0.99819, 0.61098, 0.79651, 0.61307, 0.45451, 0.88466, 0.55459, 0.35124, 0.91147, 0.14834, 0.82946, 0.65188, 0.08145, 0.84557, 0.93579, 0.13374, 0.30261, 0.95284, 0.42995, 0.37503, 0.35726, 0.75782, 0.48586, 0.53434, 0.74724, 0.19734, 0.26563, 0.42490, 0.38733, 0.26470, 0.16543, 0.93015, 0.53385, 0.30997, 0.10706, 0.34872, 0.91370, 0.45885, 0.64077, 0.80374, 0.68484, 0.25312, 0.34883, 0.67880, 0.83758, 0.57534, 0.18119, 0.07565, 0.97457, 0.15192, 0.85533, 0.03405, 0.39562, 0.78211, 0.51891, 0.32766, 0.74332, 0.19404, 0.96401, 0.59840, 0.65048, 0.81497, 0.06496, 0.04304, 0.14757, 0.09010, 0.23187, 0.19064, 0.12786, 0.17640, 0.97237, 0.53246, 0.19388, 0.05525, 0.07742, 0.54766, 0.97380, 0.83217, 0.46196, 0.96514, 0.12141, 0.26805, 0.20375, 0.68813, 0.53063, 0.95775, 0.70754, 0.65261, 0.45210, 0.14224, 0.08499, 0.86342, 0.14928, 0.58150, 0.79586, 0.14292, 0.85715, 0.82174, 0.46416, 0.15212, 0.86679, 0.65995, 0.42026, 0.43221, 0.98796, 0.87141, 0.57990, 0.55819, 0.16556, 0.93507, 0.08235, 0.12923, 0.71804, 0.86837, 0.18212, 0.93150, 0.03230, 0.82875, 0.10809, 0.53468, 0.86082, 0.93723, 0.37899, 0.39402, 0.76051, 0.95345, 0.38979, 0.95319, 0.94795, 0.78168, 0.05677, 0.16753, 0.55664, 0.15959, 0.16977, 0.87224, 0.63161, 0.30208, 0.48843, 0.45566, 0.17544, 0.20552, 0.85697, 0.94540, 0.82115, 0.99462, 0.88771, 0.74356, 0.87314, 0.20482, 0.29853, 0.55145, 0.25067, 0.29612, 0.25492, 0.17349, 0.80896, 0.51735, 0.22343, 0.24583, 0.72061, 0.37033, 0.78464, 0.41711, 0.90202, 0.95693, 0.45452, 0.09884, 0.67336, 0.02415, 0.35904, 0.73979, 0.09463, 0.56351, 0.84466, 0.40590, 0.49744, 0.67475, 0.71207, 0.44796, 0.74658, 0.73424, 0.89430, 0.60427, 0.36390, 0.78010, 0.34256, 0.39057, 0.71385, 0.42613, 0.56951, 0.06632, 0.47226, 0.95267, 0.05852, 0.81503, 0.92341, 0.47975, 0.31374, 0.41738, 0.80973, 0.16915, 0.91451, 0.58093, 0.75791, 0.15620, 0.21225, 0.07544, 0.03596, 0.06271, 0.57032, 0.24204, 0.01444, 0.53610, 0.68468, 0.58996, 0.45985, 0.65003, 0.58950, 0.01985, 0.45580, 0.48362, 0.88294, 0.52224, 0.13957, 0.92987, 0.86137, 0.10692, 0.51257, 0.68553, 0.62684, 0.12436, 0.29666, 0.19239, 0.86479, 0.66415, 0.94933, 0.13740, 0.52000, 0.65735, 0.05246, 0.85142, 0.59195, 0.42842, 0.19963, 0.35453, 0.29147, 0.70283, 0.40469, 0.78796, 0.51394, 0.77624, 0.89848, 0.67481, 0.48623, 0.25246, 0.14013, 0.43642, 0.03381, 0.91400, 0.66556, 0.80042, 0.59418, 0.26624, 0.69884, 0.91385, 0.41889, 0.74147, 0.13115, 0.94890, 0.12461, 0.35318, 0.90122, 0.84923, 0.78419, 0.81614, 0.76329, 0.01689, 0.56278, 0.90612, 0.36452, 0.40888, 0.43925, 0.04353, 0.81679, 0.98204, 0.63741, 0.91200, 0.95644, 0.86914, 0.93882, 0.32870, 0.28296, 0.63947, 0.69541, 0.97496, 0.40573, 0.77119, 0.04908, 0.94081, 0.55629, 0.62638, 0.44139, 0.50496, 0.48046, 0.74608, 0.85864, 0.42432, 0.32000, 0.75479, 0.13518, 0.44327, 0.36441, 0.78538, 0.72570, 0.84708, 0.56612, 0.65837, 0.71834, 0.70700, 0.14134, 0.95473, 0.10495, 0.93838, 0.79512, 0.63463, 0.44028, 0.42747, 0.15201, 0.16737, 0.45947, 0.87707, 0.21478, 0.01666, 0.07417, 0.61228, 0.67738, 0.95554, 0.20616, 0.48982, 0.08588, 0.64291, 0.24054, 0.48321, 0.59435, 0.49889, 0.89203, 0.08690, 0.88680, 0.40387, 0.84217, 0.28318, 0.47545, 0.17623, 0.34926, 0.55886, 0.92462, 0.36150, 0.78679, 0.39332, 0.91813, 0.14154, 0.41065, 0.47013, 0.10365, 0.49150, 0.58884, 0.78980, 0.86350, 0.37020, 0.74377, 0.11253, 0.16447, 0.34014, 0.25709, 0.53021, 0.23898, 0.51943, 0.63400, 0.26415, 0.81113, 0.10815, 0.64428, 0.31321, 0.65510, 0.91765, 0.90701, 0.64264, 0.53124, 0.40906, 0.90190, 0.77481, 0.49830, 0.61707, 0.90509, 0.16873, 0.89849, 0.18205, 0.30176, 0.86195, 0.56681, 0.63329, 0.32470, 0.51402, 0.38407, 0.26043, 0.38646, 0.30539, 0.45270, 0.47080, 0.82781, 0.99648, 0.33104, 0.86338, 0.52114, 0.12780, 0.80581, 0.13458, 0.76356, 0.92025, 0.02226, 0.08852, 0.92378, 0.35119, 0.40217, 0.75460, 0.32380, 0.77728, 0.75133, 0.93919, 0.84569, 0.65120, 0.24501, 0.44526, 0.77382, 0.87373, 0.08330, 0.70945, 0.17090, 0.98411, 0.45469, 0.21095, 0.47246, 0.99345, 0.40125, 0.04516, 0.65238, 0.82150, 0.11195, 0.39367, 0.31351, 0.96912, 0.17239, 0.10684, 0.03504, 0.29839, 0.02817, 0.54009, 0.65080, 0.28043, 0.28347, 0.49404, 0.13256, 0.04346, 0.27761, 0.51314, 0.31467, 0.32113, 0.84987, 0.45209, 0.80353, 0.13755, 0.95181, 0.73925, 0.57750, 0.20053, 0.08576, 0.42802, 0.61700, 0.02539, 0.42277, 0.38856, 0.07958, 0.39595, 0.40150, 0.01827, 0.78815, 0.15467, 0.47170, 0.63064, 0.86188, 0.94929, 0.07360, 0.03724, 0.11152, 0.52967, 0.91507, 0.44610, 0.01601, 0.49859, 0.13965, 0.34531, 0.45713, 0.06838, 0.08734, 0.38831, 0.81382, 0.38822, 0.67979, 0.33652, 0.27218, 0.27452, 0.15468, 0.13067, 0.12052, 0.10596, 0.51887, 0.43281, 0.84726, 0.82639, 0.10786, 0.09683, 0.80635, 0.25259, 0.15136, 0.18505, 0.49220, 0.34031, 0.95594, 0.58683, 0.37155, 0.64087, 0.41359, 0.46159, 0.86540, 0.00126, 0.64202, 0.89461, 0.94408, 0.70578, 0.62824, 0.69528, 0.10787, 0.25748, 0.04625, 0.01908, 0.20660, 0.36257, 0.70669, 0.76325, 0.73540, 0.24323, 0.75228, 0.21546, 0.05664, 0.65733, 0.54798, 0.76853, 0.65887, 0.10267, 0.35304, 0.92519, 0.79146, 0.15387, 0.62009, 0.78029, 0.75814, 0.19430, 0.50473, 0.66797, 0.32218, 0.04332, 0.40716, 0.31320, 0.60486, 0.64892, 0.00937, 0.84730, 0.96329, 0.34825, 0.93030, 0.60237, 0.69899, 0.46324, 0.89981, 0.23538, 0.00233, 0.91518, 0.82249, 0.74902, 0.12973, 0.64381, 0.11554, 0.91850, 0.78261, 0.38914, 0.71165, 0.59206, 0.50678, 0.70862, 0.87585, 0.42585, 0.24551, 0.50656, 0.32647, 0.73394, 0.03887, 0.22002, 0.30120, 0.68513, 0.58061, 0.20131, 0.72591, 0.61777, 0.12821, 0.40071, 0.27136, 0.86750, 0.93160, 0.72767, 0.23758, 0.40096, 0.47850, 0.49831, 0.07346, 0.86503, 0.94517, 0.25112, 0.67003, 0.02072, 0.39792, 0.43971, 0.55327, 0.61542, 0.30626, 0.69438, 0.74639, 0.07800, 0.83769, 0.11529, 0.49092, 0.06146, 0.97125, 0.46182, 0.16661, 0.21246, 0.33236, 0.52516, 0.12284, 0.12548, 0.06171, 0.24131, 0.92372, 0.72915, 0.44573, 0.62689, 0.22726, 0.53941, 0.84305, 0.50645, 0.86504, 0.95226, 0.79643, 0.44534, 0.88866, 0.49231, 0.21434, 0.59428, 0.82451, 0.41829, 0.74854, 0.08196, 0.42435, 0.70563, 0.57716, 0.34600, 0.51910, 0.15758, 0.44243, 0.50414, 0.99709, 0.80924, 0.05540, 0.41073, 0.55766, 0.39918, 0.89080, 0.87257, 0.19847, 0.66840, 0.52728, 0.85355, 0.44302, 0.25396, 0.29348, 0.79180, 0.15168, 0.43996, 0.21802, 0.16564, 0.60069, 0.17470, 0.93181, 0.16490, 0.36893, 0.28158, 0.95719, 0.22710, 0.84038, 0.61129, 0.74459, 0.29477, 0.14346, 0.29240, 0.25760, 0.52491, 0.94529, 0.64684, 0.41373, 0.39832, 0.62398, 0.38098, 0.55856, 0.00273, 0.31246, 0.37974, 0.21367, 0.77792, 0.61044, 0.16916, 0.96400, 0.69732, 0.94810, 0.67332, 0.61494, 0.77927, 0.63498, 0.79053, 0.87194, 0.20770, 0.77260, 0.53768, 0.75556, 0.05764, 0.95662, 0.10604, 0.09637, 0.37262, 0.46632, 0.50344, 0.53220, 0.22301, 0.55838, 0.24842, 0.88466, 0.12914, 0.14309, 0.18238, 0.64847, 0.98505, 0.39477, 0.88524, 0.11614, 0.01581, 0.44916, 0.33422, 0.86517, 0.28137, 0.53237, 0.81116, 0.77281, 0.32881, 0.17551, 0.74914, 0.85040, 0.33678, 0.66668, 0.12784, 0.45716, 0.95853, 0.49471, 0.27716, 0.99643, 0.55591, 0.44371, 0.86677, 0.48996, 0.19204, 0.84756, 0.61107, 0.13530, 0.87884, 0.42706, 0.22806, 0.80530, 0.56057, 0.48762, 0.83469, 0.37029, 0.43259, 0.47802, 0.49393, 0.06317, 0.08233, 0.86833, 0.45016, 0.71611, 0.33070, 0.95786, 0.02554, 0.91274, 0.94893, 0.37526, 0.25462, 0.95823, 0.06512, 0.32780, 0.56342, 0.86334, 0.01610, 0.94848, 0.35844, 0.88115, 0.85819, 0.84644, 0.85337, 0.10394, 0.82304, 0.61896, 0.23619, 0.17833, 0.12899, 0.69310, 0.56625, 0.05954, 0.17472, 0.06042, 0.81567, 0.90685, 0.14105, 0.23410, 0.30176, 0.56545, 0.13530, 0.32013, 0.78610, 0.09067, 0.83631, 0.62437, 0.45371, 0.24392, 0.72783, 0.85047, 0.99153, 0.74317, 0.79356, 0.44570, 0.42748, 0.46761, 0.50137, 0.33069, 0.36202, 0.23379, 0.69651, 0.65129, 0.16112, 0.87277, 0.31186, 0.27130, 0.84877, 0.11687, 0.65264, 0.40294, 0.75228, 0.93830, 0.52282, 0.23591, 0.36655, 0.70464, 0.32339, 0.16329, 0.80184, 0.64738, 0.94889, 0.51656, 0.29701, 0.88187, 0.92573, 0.08699, 0.52751, 0.33624, 0.02218, 0.40737, 0.87711, 0.30278, 0.42671, 0.66440, 0.42059, 0.17755, 0.89204, 0.58016, 0.84226, 0.62123, 0.93617, 0.59533, 0.70898, 0.93117, 0.37527, 0.12751, 0.51007, 0.14692, 0.78919, 0.51541, 0.56398, 0.55473, 0.02861, 0.35585, 0.80440, 0.39519, 0.38029, 0.15482, 0.40577, 0.45589, 0.60612, 0.54951, 0.81822, 0.37989, 0.89209, 0.48729, 0.73838, 0.31221, 0.78064, 0.91723, 0.60795, 0.61711, 0.22280, 0.09021, 0.92972, 0.78920, 0.56375, 0.93794, 0.87378, 0.45551, 0.56301, 0.12186, 0.06444, 0.06378, 0.99688, 0.58998, 0.44676, 0.49274, 0.29104, 0.28057, 0.24674, 0.12902, 0.22358, 0.36646, 0.85738, 0.85128, 0.71139, 0.66980, 0.50397, 0.67977, 0.83087, 0.28856, 0.15243, 0.87717, 0.70230, 0.29923, 0.11689, 0.25663, 0.39969, 0.73541, 0.75950, 0.37957, 0.06500, 0.93886, 0.47932, 0.17905, 0.94054, 0.59048, 0.82276, 0.39971, 0.84929, 0.39074, 0.89162, 0.31382, 0.96051, 0.54686, 0.55780, 0.07593, 0.60574, 0.53221, 0.54712, 0.49636, 0.93576, 0.20848, 0.20143, 0.87756, 0.28678, 0.67877, 0.60520, 0.07837, 0.34541, 0.16091, 0.55403, 0.22887, 0.91755, 0.01314, 0.78811, 0.56963, 0.18868, 0.61834, 0.83651, 0.23046, 0.16059, 0.74330, 0.09331, 0.61347, 0.97005, 0.62039, 0.36912
};

vec3 rayOrigin = vec3(0);

layout (set = 0, binding = 1) uniform Transform
{
    mat4 view;
    mat4 invproj;
} transform;

//=================
//  Materials
//-----------------
#define MAT_AIR 0
#define MAT_STONE 1
#define MAT_STONE2 2
#define MAT_STONE3 3
#define MAT_GRASS 9
#define MAT_FLOWER 10
#define MAT_WATER 19
#define MAT_PLANT_CORE 20
// ================

bool RayIntersectsCube(vec3 corner, float size, vec3 rayOrigin, vec3 rayDir, out float tMin, out float tMax) {
    // The cube is defined from corner (0, 0, 0) to corner (size, size, size)
    vec3 minBound = corner;                  // Minimum corner at (0,0,0)
    vec3 maxBound = corner + vec3(size);     // Maximum corner at (size, size, size)

    vec3 invDir = 1.0 / rayDir;
    vec3 t1 = (minBound - rayOrigin) * invDir;
    vec3 t2 = (maxBound - rayOrigin) * invDir;

    vec3 tMinVec = min(t1, t2);
    vec3 tMaxVec = max(t1, t2);

    tMin = max(max(tMinVec.x, tMinVec.y), tMinVec.z);
    tMax = min(min(tMaxVec.x, tMaxVec.y), tMaxVec.z);

    return tMax >= tMin && tMax >= 0.0;
}

uint GetVoxel(ivec3 position)
{
    ivec3 chunkPosition = ivec3(vec3(float(position.x / 128.0), float(position.y / 128.0), float(position.z / 128.0)));
    uint value = uint(imageLoad(voxelChunkMap, ivec3(chunkPosition)));

    return uint(imageLoad(voxelData[nonuniformEXT(value)], ivec3(mod(position.x, 128), mod(position.y, 128), mod(position.z, 128))));
}
vec3 calculateVoxelNormal(ivec3 pos) {
    // Get material value (0 = air, nonzero = solid)
    uint cx = GetVoxel(pos) & 31;
    
    // If the center voxel is air, return zero normal
    if (cx == 0) {
        return vec3(0.0);
    }

    vec3 normal = vec3(0.0);
    float weightTotal = 0.0;

    // Loop through a 7x7x7 neighborhood (radius = 3)
    for (int x = -3; x <= 3; x++) {
        for (int y = -3; y <= 3; y++) {
            for (int z = -3; z <= 3; z++) {
                if (x == 0 && y == 0 && z == 0) continue; // Skip the center voxel
                
                ivec3 neighborPos = pos + ivec3(x, y, z);
                uint material = GetVoxel(neighborPos) & 31;
                float weight = 1.0 / (1.0 + length(vec3(x, y, z))); // Closer neighbors contribute more
                
                if (material > 0) { // If solid, contribute to normal
                    normal += weight * vec3(x, y, z);
                    weightTotal += weight;
                }
            }
        }
    }

    // Normalize the result if there was any contribution
    return weightTotal > 0.0 ? normalize(normal) : vec3(0.0);
}


bool DistanceToCubeSurface(vec3 pointInside, vec3 direction, vec3 corner, float size, out float distance) {
    // Define the minimum and maximum bounds of the cube
    direction = normalize(direction);
    vec3 minBound = corner;                  // Minimum corner at (0, 0, 0)
    vec3 maxBound = corner + vec3(size);     // Maximum corner at (size, size, size)
    
   // Calculate t values for each axis (distance to each face in the direction)
    vec3 t1 = (minBound - pointInside) / direction;
    vec3 t2 = (maxBound - pointInside) / direction;
    
    // Swap t1 and t2 if direction is negative (so t1 refers to the closer intersection)
    vec3 tMinVec = min(t1, t2);  // Smallest values for entry to the cube
    vec3 tMaxVec = max(t1, t2);  // Largest values for exit from the cube
    
    // The distance is the smallest positive tMax where the direction is outward
    distance = max(max(tMinVec.x, tMinVec.y), tMinVec.z);  // Use the smallest positive tMax for the hit point
    
    
    // Check if the point is actually inside the cube and the direction is outward
    return (distance >= 0.0); 
}

vec4 computer_ray_dir(uvec3 launchID, uvec3 launchSize)
{
    float x = (2 * float(launchID.x) + 0.5) / float(launchSize.x) - 1.0;
    float y = (1.0 - 2 * (float(launchID.y) + 0.5) / float(launchSize.y));

    vec4 direction = transform.invproj * vec4(x,y,1,1);
    direction = normalize(direction);

    return direction;
}

float randomFloat(ivec2 seed, int sampleIndex) {
    uint hash = uint(seed.x) * 73856093u ^ uint(seed.y) * 19349663u ^ uint(sampleIndex) * 83492791u;
    return fract(sin(float(hash) * 0.00000001) * 43758.5453);
    return random[min(sampleIndex, 2047)];
    // return 0.5;
}

vec3 getBounceDirection(vec3 normal, vec3 outgoingRay, int sampleIndex, ivec2 seed, float roughness) {
    float alpha2 = roughness * roughness; // Precompute α²
    float u1 = randomFloat(seed, sampleIndex);
    float u2 = randomFloat(seed, sampleIndex + 1);

    // GGX Importance Sampling
    float cosTheta = sqrt((1.0 - u1) / (1.0 + (alpha2 - 1.0) * u1));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    float phi = 6.28318530718 * u2; // 2π * u2

    // Convert to world space using optimized orthonormal basis
    vec3 tangent = normalize(abs(normal.z) > 0.999 ? vec3(1.0, 0.0, 0.0) : cross(vec3(0.0, 0.0, 1.0), normal));
    vec3 bitangent = cross(normal, tangent);

    // Compute half-vector
    vec3 halfVector = normalize(tangent * cos(phi) * sinTheta + bitangent * sin(phi) * sinTheta + normal * cosTheta);

    // Compute final bounce direction
    return normalize(outgoingRay - 2.0 * dot(outgoingRay, halfVector) * halfVector);
}

float semiRandomFloat(ivec3 inp) {
    // A simple hashing function using the input vector components

    uint hash = inp.x * 123456789 + inp.y * 987654321 + inp.z * 567890123;
    
    // A bitwise operation to mix the hash value
    hash = (hash ^ (hash >> 21)) * 2654435761u;
    hash = hash ^ (hash >> 21);
    hash = hash * 668265263;
    hash = hash ^ (hash >> 21);

    // Return a float between 0 and 1 based on the hash
    return float(hash & 0xFFFFFFF) / float(0xFFFFFFF);
}

const vec3 FOG_COLOR = vec3(10.0/256.0, 5.0/256.0, 15.0/256);
const vec3 FLOWER_COLRS[] = {vec3(0.8, 0.2, 0.2), vec3(0.0, 0.4, 0.2), vec3(0.5, 0.5, 0.1), vec3(0.95, 0.95, 0.95)};

vec4 getColor(uint material, float d, vec3 hit)
{
    vec3 c = vec3(0.0);
    switch (material)
    {
        case MAT_STONE:
            c = vec3(0.15) * (1.0 - (semiRandomFloat(ivec3(hit.z + (uint(semiRandomFloat(ivec3(hit/2))*2)), 0, 0)) - 0.5) * 0.15);
            break;
        case MAT_STONE2:
            c = vec3(0.15) * (1.0 - (semiRandomFloat(ivec3(hit.z+(uint(semiRandomFloat(ivec3(hit/3))*2)), 0, 0)) - 0.5) * 0.15);
            break;
        case MAT_STONE3:
            c = vec3(0.15) * (1.0 - (semiRandomFloat(ivec3(hit.z+(uint(semiRandomFloat(ivec3(hit/4))*2)), 0, 0)) - 0.5) * 0.15);
            break;
        case MAT_GRASS:
            c = vec3(0.2, 0.5, 0) * (1.0 - (semiRandomFloat(ivec3(hit.z, 0, 0)) - 0.5) * 0.2);
            break;
        case MAT_FLOWER:
            c = FLOWER_COLRS[int(floor(min(semiRandomFloat(ivec3(hit.z, 0, 0)) * 4, 3.5)))];
            break;
        case MAT_WATER:
            c = vec3(0.0, 0.1, 0.5);
            break;
        case MAT_PLANT_CORE:
            c = vec3(0.4, 0.2, 0.6);
            break;
        default:
            break;
    }
    // if (material != MAT_AIR)
    // {
    //     c = mix(c, FOG_COLOR, clamp((d - 100.0) / 50.0, 0.0, 1.0));
    // }
    return vec4(c, 1.0);
}

struct Payload
{
    vec3 hit;
    float dist;
    uint material;
    vec4 color;
};

Payload march(vec3 rayOrigin, vec3 rayDir, float maxDistance)
{
    float tMax = 0, tMin = 0;

    ivec3 origin = ivec3(0);
    int size = 1024;

    if (rayOrigin.x > 0 && rayOrigin.y > 0 && rayOrigin.z > 0)
    {
        origin = ivec3(rayOrigin);
        size = 1;
    }

    uint value = GetVoxel(ivec3(origin));
    uint layer = ((value >> 5) & 7) ;
    uint material = value & 31;

        vec3 hit = rayOrigin;
    if (RayIntersectsCube((origin / uint(pow(2, layer))) * uint(pow(2, layer)), uint(pow(2, layer)), rayOrigin, rayDir, tMin, tMax))
    {
        float distanceToBox = tMin;
        float rayDistance = distanceToBox;

        if (rayOrigin.x > 0 && rayOrigin.y > 0 && rayOrigin.z > 0)
        {
            distanceToBox = abs(tMax);
        }
        hit += rayDir * distanceToBox; //distanceToBox;
        hit += rayDir * 0.005;

        value = GetVoxel(ivec3(hit));
        layer = ((value >> 5) & 7);
        material = value & 31;
        
        if (material != MAT_AIR)
        {
            Payload p;
            p.dist = rayDistance;
            p.hit = hit;
            p.color = getColor(material, length(rayOrigin - hit), hit);
            p.material = material;
            return p;
        }

        for (int i = 0; i < 500; i++)
        {
            RayIntersectsCube((ivec3(hit) / uint(pow(2, layer))) * uint(pow(2, layer)), uint(pow(2, layer)), rayOrigin, rayDir, tMin, tMax);
            distanceToBox = abs(tMin - tMax);
            hit += rayDir * distanceToBox;
            rayDistance += distanceToBox;

            value = GetVoxel(ivec3(hit));
            layer = ((value >> 5) & 7);
            material = value & 31;

            if (material != MAT_AIR)
            {   
                Payload p;
                p.dist = rayDistance;
                p.hit = hit;
                p.color = getColor(material, length(rayOrigin - hit), hit);
                p.material = material;
                return p;
            }

            if (rayDistance > maxDistance) break;
        }
    }
    Payload p;
    p.hit = hit;
    p.material = 0;
    p.color = vec4(FOG_COLOR, 1.0);
    p.dist = 200;
    return p;
}

vec3 bilinearInterpolation(vec3 C00, vec3 C10, vec3 C01, vec3 C11, vec2 uv) {
    vec3 C0 = mix(C00, C10, uv.x);
    vec3 C1 = mix(C01, C11, uv.x);
    return mix(C0, C1, uv.y);
}

vec3 interpolateColor(vec3 c1, vec3 c2, vec3 c3, vec3 c4, float d1, float d2, float d3, float d4) {
    // Prevent division by zero by clamping distances
    d1 = max(d1, 0.0001);
    d2 = max(d2, 0.0001);
    d3 = max(d3, 0.0001);
    d4 = max(d4, 0.0001);

    // Compute weights using inverse square distance (IDW with p=2)
    float w1 = 1.0 / (d1 * d1);
    float w2 = 1.0 / (d2 * d2);
    float w3 = 1.0 / (d3 * d3);
    float w4 = 1.0 / (d4 * d4);

    // Normalize weights
    float sumW = w1 + w2 + w3 + w4;
    w1 /= sumW;
    w2 /= sumW;
    w3 /= sumW;
    w4 /= sumW;

    // Compute final interpolated color
    return c1 * w1 + c2 * w2 + c3 * w3 + c4 * w4;
}

// vec3 GetVoxelLightContribution(vec3 hit, uint material, ivec2 pixelCoord, int pixelSpread)
// {

//             if (ivec4(mod(ivec3(hit), 128), 1.0) == imageLoad(positionImage, (pixelCoord / pixelSpread)))
//             {
//                 return imageLoad(lightImage, ((pixelCoord / pixelSpread) * pixelSpread)).xyz * 64.0;
//             }
//             else if (ivec4(mod(ivec3(hit), 128), 1.0) == imageLoad(positionImage, ((pixelCoord / pixelSpread)) + ivec2(1, 0)))
//             {
//                 return imageLoad(lightImage, ((pixelCoord / pixelSpread) * pixelSpread) + ivec2(pixelSpread, 0)).xyz * 64.0;
//             }
//             else if (ivec4(mod(ivec3(hit), 128), 1.0) == imageLoad(positionImage, ((pixelCoord / pixelSpread)) + ivec2(0, 1)))
//             {
//                 return imageLoad(lightImage, ((pixelCoord / pixelSpread) * pixelSpread) + ivec2(0, pixelSpread)).xyz * 64.0;
//             }
//             else if (ivec4(mod(ivec3(hit), 128), 1.0) == imageLoad(positionImage, ((pixelCoord / pixelSpread)) + ivec2(1, 1)))
//             {
//                 return imageLoad(lightImage, ((pixelCoord / pixelSpread) * pixelSpread) + ivec2(pixelSpread, pixelSpread)).xyz * 64.0;
//             }
//             else
//             {
//                 vec3 colorv1 = imageLoad(lightImage, ((pixelCoord / pixelSpread) * pixelSpread)).xyz * 64.0;
//                 vec3 colorv2 = imageLoad(lightImage, ((pixelCoord / pixelSpread) * pixelSpread) + ivec2(pixelSpread, 0)).xyz * 64.0;
//                 vec3 colorv3 = imageLoad(lightImage, ((pixelCoord / pixelSpread) * pixelSpread) + ivec2(0, pixelSpread)).xyz * 64.0;
//                 vec3 colorv4 =imageLoad(lightImage, ((pixelCoord / pixelSpread) * pixelSpread) + ivec2(pixelSpread, pixelSpread)).xyz * 64.0;

//                 vec3 posv1 = imageLoad(positionImage, pixelCoord / pixelSpread).xyz;
//                 vec3 posv2 = imageLoad(positionImage, pixelCoord / pixelSpread + ivec2(1, 0)).xyz;
//                 vec3 posv3 = imageLoad(positionImage, pixelCoord / pixelSpread + ivec2(0, 1)).xyz;
//                 vec3 posv4 = imageLoad(positionImage, pixelCoord / pixelSpread + ivec2(1, 1)).xyz;

//                 vec3 voxelPos = mod(ivec3(hit), pixelSpread);

//                 float distance1 = distance(posv1, voxelPos);
//                 float distance2 = distance(posv2, voxelPos);
//                 float distance3 = distance(posv3, voxelPos);
//                 float distance4 = distance(posv4, voxelPos);

//                 distance1 = pow(distance1, 4);
//                 distance2 = pow(distance2, 4);
//                 distance3 = pow(distance3, 4);
//                 distance4 = pow(distance4, 4);



//                 return interpolateColor(colorv1.xyz, colorv2.xyz, colorv3.xyz, colorv4.xyz, distance1, distance2, distance3, distance4);
//             }

//             return vec3(0.0, 0.0, 0.0);
// }

// void main()
// {



//     ivec2 pixelCoord = ivec2(gl_LaunchIDEXT.xy);


//     // vec2 ndc = (vec2(pixelCoord) / gl_LaunchSizeEXT.xy) * 2.0 - 1.0;
//     rayOrigin = -transform.view[3].xyz;

//     int pixelSpread = 14;
//     vec4 rayWorldSpace;
//     if (pushConstants.flag == 0)
//     {
//         rayWorldSpace = computer_ray_dir((gl_LaunchIDEXT.xyz / pixelSpread) * pixelSpread, gl_LaunchSizeEXT.xyz);
//     }
//     else
//     {
//         rayWorldSpace = computer_ray_dir(gl_LaunchIDEXT.xyz, gl_LaunchSizeEXT.xyz);
//     }
//     // rayWorldSpace /= rayWorldSpace.w;
//     mat4 copy = transform.view;
//     copy[3] = vec4(0.0, 0.0, 0.0, 1.0);
//     vec3 rayDir = normalize((copy * rayWorldSpace).xyz);


//     if (pushConstants.flag == 0)
//     {
//         // if (mod(pixelCoord.x, pixelSpread) == 0 && mod(pixelCoord.y, pixelSpread) == 0)
//         // {

//             if (mod(pixelCoord.x, pixelSpread) == 0 && mod(pixelCoord.y, pixelSpread) == 0)
//             {
//                 Payload p = march(rayOrigin, rayDir, 200.0);
//                 vec3 hit = p.hit;
//                 float distance1 = p.dist;
//                 // imageStore(imageOutput, pixelCoord, p.color);
//             }
//             else
//             {
//                     Payload p = march(rayOrigin, rayDir, 200.0);
//                     vec4 color1 = p.color;
//                     float distance1 = p.dist;
//                     vec3 hit = p.hit;
//                     vec3 normal = calculateVoxelNormal(ivec3(hit));
//                     float distance2;
//                     vec3 hit2;
//                 vec3 contribution = vec3(0);
//                 int sampleCount = 8;
//                 for (int i = 0; i < sampleCount; i++)
//                 {
                    
//                     vec3 reflectDirection = normalize(-reflect(normalize(rayOrigin - ivec3(hit)), normalize(normal)));
//                     ivec2 moddedCoords = ivec2(mod(pixelCoord, pixelSpread));
//                     vec3 bounceDirection = getBounceDirection(normalize(normal), reflectDirection, i, moddedCoords + ivec2(20, 20) * int(pushConstants.frame), 1); 
//                     // vec3 bounceDirection = sampleBRDF(2.0, normalize(reflectDirection), normalize(normal), pixelSpread * pixelSpread * sampleCount, (((moddedCoords.x * pixelSpread) + moddedCoords.y) * sampleCount) + i);
//                     p = march(ivec3(hit) + bounceDirection, bounceDirection, 100.0);
//                     vec4 bounceColor = p.color;
//                     uint material = p.material;
//                     distance2 = p.dist;
//                     hit2 = p.hit;
//                     // imageStore(sparseImage, (pixelCoord / pixelSpread) * 2, ivec4(mod(ivec3(hit), 128), 1));
//                     imageStore(positionImage, (pixelCoord / pixelSpread), ivec4(mod(ivec3(hit), 128), 1));


//                     float attenuation = exp(-0.1 * distance2);
//                     float angularFactor = max(dot(normalize(rayDir), normalize(bounceDirection)), 0.0);
//                     vec4 lightContribution = (bounceColor * 1) * attenuation * angularFactor;
//                     if (material == MAT_GRASS)
//                     {
//                         lightContribution *= 15;
//                     }
//                     else if (material == MAT_PLANT_CORE)
//                     {
//                         lightContribution *= 1000;
//                     }
//                     contribution += vec3(lightContribution) / sampleCount;
//                 }
//                     imageStore(lightImage, pixelCoord, vec4(contribution/64.0, 1.0));

            
            
            
//             //imageStore(imageOutput, pixelCoord, vec4(mix(mix(color1, bounceColor, factor).xyz, FOG_COLOR, clamp((length(rayOrigin - hit) - 100.0) / 50.0, 0.0, 1.0)), 1.0));
//         // }
//         }
//     }
//     else if (pushConstants.flag == 1)
//     {
//         if (mod(pixelCoord.x, pixelSpread) == 0 && mod(pixelCoord.y, pixelSpread) == 0)
//         {
//             vec4 color = vec4(0);
//             for (int x = 0; x < pixelSpread; x++)
//             {
//                 for (int y = 0; y < pixelSpread; y++)
//                 {
//                     if (x != 0 || y != 0)
//                     {
//                         color += (imageLoad(lightImage, pixelCoord + ivec2(x, y)) * 64.0) / ((pixelSpread * pixelSpread) - 1);
//                         // imageStore(imageOutput, pixelCoord + ivec2(x, y), vec4(FOG_COLOR, 1));
//                     }
//                 }
//             }
//             // imageStore(sparseImage, ((pixelCoord / pixelSpread) * 2) + ivec2(1, 0), ivec4(color * 255));
//             imageStore(lightImage, pixelCoord, color / 64.0);
//             return;
//         }
//         return;
//     }
//     else if (pushConstants.flag == 2)
//     {
//         // if (mod(pixelCoord.x, pixelSpread) != 0 || mod(pixelCoord.y, pixelSpread) != 0)
//         // {
//             Payload p = march(rayOrigin, rayDir, 200.0);
//             vec3 hit = p.hit;
//             float distance1 = p.dist;
//             vec4 color1 = p.color;
//             uint material = p.material;
//         float lightContributionMultiplier = 1.0;
//             if (material == MAT_GRASS)
//             {
//                 lightContributionMultiplier = 0.3;
//             }
//             else if (material == MAT_PLANT_CORE)
//             {
//                 lightContributionMultiplier = 0.1;
//             }
     
       
//             vec3 light = lightContributionMultiplier * GetVoxelLightContribution(hit, material, pixelCoord, pixelSpread) * vec3(color1);
//             vec4 color = vec4(mix(light, FOG_COLOR, clamp((length(rayOrigin - hit) - 100.0) / 75.0, 0.0, 1.0)), 1.0);
// float frame = float(pushConstants.frame);
// vec4 finalColor = color;
// if (frame > 1)
// {
//             vec4 lastColor = imageLoad(imageOutput, pixelCoord);

//             finalColor = lastColor * ((frame - 1) / frame) + color * (1 / frame);
// }

//             imageStore(imageOutput, pixelCoord, finalColor);
//     }

 
// }

ivec2 worldToPixel(vec3 worldPos, mat4 view, mat4 proj, ivec2 screenSize) {
    // Transform world position to clip space
    view = inverse(view);
    proj = inverse(proj);
    vec4 clipSpacePos = proj * view * vec4(worldPos, 1.0);

    // Handle w = 0 case to prevent errors
    if (abs(clipSpacePos.w) < 0.0001) {
        return ivec2(-1, -1); // Return invalid coordinates
    }

    // Perform perspective divide to get Normalized Device Coordinates (NDC)
    vec3 ndc = clipSpacePos.xyz / clipSpacePos.w;

    // Convert NDC (-1 to 1) to screen space (0 to screenSize)
    ivec2 pixelCoords = ivec2(((ndc.xy + 1.0) * 0.5) * screenSize);
    return (pixelCoords / 2) + screenSize / 4;

}

void main()
{

    ivec2 pixelCoord = ivec2(gl_LaunchIDEXT.xy);


    // vec2 ndc = (vec2(pixelCoord) / gl_LaunchSizeEXT.xy) * 2.0 - 1.0;
    rayOrigin = -transform.view[3].xyz;

    int pixelSpread = 14;
    vec4 rayWorldSpace;
    if (pushConstants.flag == 13)
    {
        rayWorldSpace = computer_ray_dir((gl_LaunchIDEXT.xyz / pixelSpread) * pixelSpread, gl_LaunchSizeEXT.xyz);
    }
    else
    {
        rayWorldSpace = computer_ray_dir(gl_LaunchIDEXT.xyz, gl_LaunchSizeEXT.xyz);
    }
    // rayWorldSpace /= rayWorldSpace.w;
    mat4 copy = transform.view;
    copy[3] = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 rayDir = normalize((copy * rayWorldSpace).xyz);


    if (pushConstants.flag == 0)
    {

        uint z = 0;
        imageStore(lightImageX, pixelCoord, ivec4(0));
        imageStore(lightImageY, pixelCoord, ivec4(0));
        imageStore(lightImageZ, pixelCoord, ivec4(0));
        imageStore(lightImageW, pixelCoord, ivec4(0));

    }
    else if (pushConstants.flag == 1)
    {
                // if (mod(pixelCoord.x, pixelSpread) == 0 && mod(pixelCoord.y, pixelSpread) == 0)
        // {

       Payload p = march(rayOrigin, rayDir, 200.0);
        vec3 hit = p.hit;
        vec4 color1 = p.color;
        float distance1 = p.dist;
        vec3 normal = calculateVoxelNormal(ivec3(hit));

        vec3 contribution = vec3(0);
        const int sampleCount = 10;

        ivec2 screenPos = worldToPixel(-ivec3(hit), transform.view, transform.invproj, ivec2(gl_LaunchSizeEXT.xy));
        uint num = imageAtomicAdd(positionImage, screenPos, 1);

        vec3 reflectDirection = reflect(rayOrigin - hit, normal); // Already normalized if inputs are normalized
        vec3 baseBounceDirection = normalize(-reflectDirection); // Avoid recalculating in loop

        for (int i = 0; i < sampleCount; i++) {
            int sampleIndex = int(num) * sampleCount + i;

            vec3 bounceDirection = getBounceDirection(normal, baseBounceDirection, sampleIndex, ivec2(20, 20), 1); 

            p = march(ivec3(hit) + bounceDirection, bounceDirection, 100.0);
            vec4 bounceColor = p.color;
            float distance2 = p.dist;
            uint material = p.material;

            // Reduce redundant operations
            vec3 hit2 = p.hit;
            ivec3 hitMod = ivec3(mod(hit, 128.0));

            // Store sparse image only once per loop iteration
            imageStore(positionImage, (pixelCoord / pixelSpread), ivec4(hitMod, 1));

            // Compute light contribution efficiently
            float attenuation = exp(-0.1 * distance2);
            float angularFactor = max(dot(rayDir, bounceDirection), 0.0);
            float materialFactor = (material == MAT_GRASS) ? 8.0 : (material == MAT_PLANT_CORE) ? 500.0 : 1.0;

            vec3 lightContribution = (bounceColor.rgb * 2.0 * attenuation * angularFactor * materialFactor) / float(sampleCount);
            contribution += lightContribution;
        }
        uvec4 c = uvec4(contribution.xyz * 256, 1);
        imageAtomicAdd(lightImageX, screenPos, c.x);
        imageAtomicAdd(lightImageY, screenPos, c.y);
        imageAtomicAdd(lightImageZ, screenPos, c.z);
        imageAtomicAdd(lightImageW, screenPos, 1);
    }
    else if (pushConstants.flag == 2)
    {
                    Payload p = march(rayOrigin, rayDir, 200.0);
            vec3 hit = p.hit;
            float distance1 = p.dist;
            vec4 color1 = p.color;
            uint material = p.material;
            // ivec2 screenPos = worldToPixel(-ivec3(hit), transform.view, transform.invproj, gl_LaunchSizeEXT.xy);
            // vec4 light1 = vec4(uint(imageLoad(lightImageX, screenPos)), uint(imageLoad(lightImageY, screenPos)), uint(imageLoad(lightImageZ, screenPos)), uint(imageLoad(lightImageW, screenPos)));
            // vec3 light2 = vec3(light1) / light1.w;
            // vec3 light5 = light2 / 256.0; //lightContributionMultiplier * GetVoxelLightContribution(hit, material, pixelCoord, pixelSpread) * vec3(color1);
            // imageStore(imageOutput, pixelCoord, vec4(light, 1.0));

            // vec4 light5 = vec4(uint(imageLoad(lightImageX, screenPos)), uint(imageLoad(lightImageY, screenPos)), uint(imageLoad(lightImageZ, screenPos)), uint(imageLoad(lightImageW, screenPos)));
            // imageStore(imageOutput, pixelCoord, vec4(light5.xyz, 1.0));
        // // if (mod(pixelCoord.x, pixelSpread) != 0 || mod(pixelCoord.y, pixelSpread) != 0)
        // // {
        //     Payload p = march(rayOrigin, rayDir, 200.0);
        //     vec3 hit = p.hit;
        //     float distance1 = p.dist;
        //     vec4 color1 = p.color;
        //     uint material = p.material;
        // vec3 light5 = vec3(0);
        // float divide = 0;
        // for (int x = -1; x <= 1; x++)
        // {
        //     for (int y = -1; y <= 1; y++)
        //     {
        //         for (int z = -1; z <= 1; z++)
        //         {
        //             ivec2 screenPos = worldToPixel(-ivec3(hit) + ivec3(x, y, z), transform.view, transform.invproj, gl_LaunchSizeEXT.xy);
        //             vec4 light1 = vec4(uint(imageLoad(lightImageX, screenPos)), uint(imageLoad(lightImageY, screenPos)), uint(imageLoad(lightImageZ, screenPos)), uint(imageLoad(lightImageW, screenPos)));
        //             float multiplyer = 1.0 - length(vec3(x, y, z))/2.0;
        //             if (light1.w != 0)
        //             {
        //                 light5 += ((light1.xyz / 256.0) / light1.w) * multiplyer;
        //                 divide += multiplyer;
        //             }
        //         }   
        //     }   
        // }
        // light5 /= divide;

        vec3 light5 = vec3(0);
float divide = 0;

// for (int x = -1; x <= 1; x++) {
//     for (int y = -1; y <= 1; y++) {
//         for (int z = -1; z <= 1; z++) {
//             ivec2 screenPos = worldToPixel(-ivec3(hit) + ivec3(x, y, z), transform.view, transform.invproj, gl_LaunchSizeEXT.xy);
//             vec4 light1 = vec4(uint(imageLoad(lightImageX, screenPos)), uint(imageLoad(lightImageY, screenPos)), uint(imageLoad(lightImageZ, screenPos)), uint(imageLoad(lightImageW, screenPos)));

//             if (light1.w != 0) {
//                 vec3 lightValue = (light1.xyz / 256.0) / light1.w;
//                 float weight = 1.0 - (length(vec3(x, y, z)) / 3.0); // Closer samples matter more
//                 light5 += lightValue * weight;
//                 divide += weight;
//             }
//         }
//     }
// }
ivec2 screenPos = worldToPixel(-ivec3(hit) , transform.view, transform.invproj, ivec2(gl_LaunchSizeEXT.xy));
vec4 light1 = vec4(uint(imageLoad(lightImageX, screenPos)), uint(imageLoad(lightImageY, screenPos)), uint(imageLoad(lightImageZ, screenPos)), uint(imageLoad(lightImageW, screenPos)));

    vec3 lightValue = (light1.xyz / 256.0) / light1.w;
    light5 += lightValue;





        float lightContributionMultiplier = 1.0;
            if (material == MAT_GRASS)
            {
                lightContributionMultiplier = 0.3;
            }
            else if (material == MAT_PLANT_CORE)
            {
                lightContributionMultiplier = 0.1;
            }
     
       
            vec3 light = lightContributionMultiplier * light5*  vec3(color1);
            vec4 color = vec4(mix(light, FOG_COLOR, clamp((length(rayOrigin - hit) - 100.0) / 75.0, 0.0, 1.0)), 1.0);
            float frame = float(pushConstants.frame);
            vec4 finalColor = color;
            // if (frame > 1)
            // {
            //     vec4 lastColor = imageLoad(imageOutput, pixelCoord);

            //     finalColor = lastColor * ((frame - 1) / frame) + color * (1 / frame);
            // }

            imageStore(imageOutput, pixelCoord, finalColor);
            imageStore(positionImage, pixelCoord, ivec4(0));
    }

 
}